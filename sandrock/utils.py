'''
Basic utility methods.
'''

from .std import *
from .dump import lua_dump, yaml_dump

# ------------------------------------------------------------------------------

# Wildcard export methods.
__all__ = [
    'read_asset_dump',
    'read_json',
    'sorted_dict',
    'write_json',
    'write_lua',
    'write_text',
    'write_xml',
    'write_yaml',
]

# Key, Type, Value
K = TypeVar('K')
T = TypeVar('T')
V = TypeVar('V')

# ------------------------------------------------------------------------------

# For .txt dump files generated by AssetStudioMod. Original author of the 
# scripts seemed to be able to get JSON for MonoScripts and GameObjects, but my
# version doesn't provide that format, so we work around it by parsing the txt.
def read_asset_dump(path: PathLike) -> dict:
    assert str(path).endswith('.txt')
    with open(path) as f:
        asset_text = f.read()
        return(_parse_asset_dump(asset_text.splitlines()))

# Overload with multiple call signatures.
# If called only with a path, the output type is indeterminate.
@overload
def read_json(Path: PathLike) -> Any: ...
# If called with a type, the output should be that type.
@overload
def read_json(Path: PathLike, json_type: Type[T]) -> T: ...
def read_json(path, json_type=None):
    with open(path, encoding='utf-8') as f:
        return json.load(f)

# Sort dictionary by its keys.
def sorted_dict(dict_: dict[K, V]) -> dict[K, V]:
    return dict(sorted(dict_.items()))

# -- Output Methods ------------------------------------------------------------

def write_json(path: PathLike, data: Any) -> None:
    with open(_resolve_path(path), 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=4)

def write_lua(path: PathLike, data: Any, indent: str = '\t') -> None:
    s = lua_dump(data, '', indent)
    _resolve_path(path).write_text('return ' + s, encoding='utf-8')

def write_text(path: PathLike, text: str) -> None:
    with open(_resolve_path(path), 'w', encoding='utf-8') as f:
        f.write(text)

def write_xml(path: PathLike, root: ElementTree.Element) -> None:
    ElementTree.ElementTree(root).write(_resolve_path(path), 'utf_8')

def write_yaml(path: PathLike, data: Any) -> None:
    s = yaml_dump(data, '', '    ')
    if isinstance(s, list):
        s = '\n'.join(s)
    _resolve_path(path).write_text(s)

# -- Private -------------------------------------------------------------------

def _resolve_path(path: PathLike) -> Path:
    path = Path(path)
    if not path.is_absolute():
        from .common import config
        path = config.output_dir / path
    path.parent.mkdir(parents=True, exist_ok=True)
    return path

def _parse_asset_dump(lines: list[str]) -> dict:
    result             = {}
    array_index        = 0
    indent_level_stack = [0]
    stack              = [result]

    for line in lines[1:]:
        stripped = line.strip()

        # Empty line.
        if not stripped: continue
        
        indent_level          = len(line) - len(stripped)
        previous_indent_level = indent_level_stack[-1]
        
        while indent_level_stack and indent_level < indent_level_stack[-1]:
            stack.pop()
            indent_level_stack.pop()
          
        if indent_level_stack and indent_level > indent_level_stack[-1]:
            indent_level_stack.append(indent_level)
        
        current = stack[-1]
        is_array_size  = isinstance(current, list) and stripped.startswith('int size =')

        # Empty array/dictionary? Pop an element off the stack if:
        #   - We read an array size of 0.
        #   - The last item on the stack is an empty dictionary, and this line 
        #     has the same indent.
        if is_array_size:
            if stripped == 'int size = 0':
                stack.pop()
            continue
        
        if current == {} and indent_level == previous_indent_level:
            stack.pop()

        # Is key-value pair? Assign it to the current dictionary or array.
        if ' = ' in stripped:
            type_key, value = map(str.strip, stripped.rsplit('=', 1))
            type, key       = type_key.rsplit(' ', 1)
            if type in ['int', 'SInt64', 'UInt8', 'unsigned int']:
                value = int(value)
            elif type == 'float':
                value = float(value)
            elif type == 'bool':
                value = value.lower() == 'true'
            
            if isinstance(current, list):
                current[array_index] = value
            else:
                current[key] = value
        # Is array index? Prepare the current array by making sure the index 
        # exists.
        elif re.match(r"^\[\d+\]$", stripped):
            array_index = int(stripped.strip("[]"))
            if isinstance(current, list):
                while len(current) <= array_index:
                    current.append(None)
        else:
            type, key = stripped.rsplit(' ', 1)
            if type == 'Array':
                value = []
            # Everything else is a dictionary-like.
            else:
                value = {}
            
            if isinstance(current, list):
                current[array_index] = value
                stack.append(current[array_index])
            else:
                current[key] = value
                stack.append(current[key])
    
    return result
